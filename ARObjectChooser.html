<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>AR Spawn Objects & Bounding Boxes</title>

<script type="importmap">
{
    "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/"
    }
}
</script>

<style>
body { margin: 0; overflow: hidden; }
#menu {
    position: absolute; top: 10px; left: 10px;
    z-index: 10;
    background: white;
    padding: 12px;
    border-radius: 8px;
}
button { margin: 4px; }
</style>
</head>
<body>

<div id="menu">
    <button id="arStart">Start AR</button><br>
    <button class="objBtn" data-type="cube">Cube</button>
    <button class="objBtn" data-type="chair">Chair</button>
    <button class="objBtn" data-type="box">Box</button>
    <button class="objBtn" data-type="lamp">Lamp</button>
</div>

<script type="module">

import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { ARButton } from 'three/addons/webxr/ARButton.js';

let scene, camera, renderer, reticle, controller;
let hitTestSource = null, hitTestRequested = false;

let selectedType = "cube";

const loader = new GLTFLoader();

// Load GLB assets
const assets = {
    chair: null,
    box: null,
    lamp: null
};

loader.load("chair.glb", gltf => assets.chair = gltf.scene );
loader.load("box.glb", gltf => assets.box = gltf.scene );
loader.load("lamp.glb", gltf => assets.lamp = gltf.scene );

// Simple colored cube model
function createCube() {
    const geo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
    const mat = new THREE.MeshStandardMaterial({ color: 0x4488ff });
    return new THREE.Mesh(geo, mat);
}

// Create label
function makeTextLabel(text) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    ctx.font = "50px Arial";
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 6;

    ctx.strokeText(text, 10, 60);
    ctx.fillText(text, 10, 60);

    const tex = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
    sprite.scale.set(0.35, 0.15, 1);
    return sprite;
}

// Bounding box + label
function addBoundingBoxAndLabel(obj) {
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3();
    box.getSize(size);

    const width = size.x.toFixed(2);
    const height = size.y.toFixed(2);

    const helper = new THREE.Box3Helper(box, 0xff0000);
    scene.add(helper);

    const center = new THREE.Vector3();
    box.getCenter(center);

    const label = makeTextLabel(`W: ${width}m  H: ${height}m`);
    label.position.set(center.x, center.y + size.y * 0.7, center.z);

    scene.add(label);
}

init();
animate();


function init() {

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 40);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff,0x777777,1.2);
    scene.add(light);

    // Reticle
    reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.08,0.12,32).rotateX(-Math.PI/2),
        new THREE.MeshBasicMaterial({ color:0x00ff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Controller
    controller = renderer.xr.getController(0);
    controller.addEventListener("select", spawnObject);
    scene.add(controller);

    // Object selection buttons
    document.querySelectorAll(".objBtn").forEach(btn => {
        btn.addEventListener("click", () => {
            selectedType = btn.dataset.type;
        });
    });

    // AR button
    const ARbtn = ARButton.createButton(renderer, { requiredFeatures:['hit-test'] });
    document.getElementById("arStart").addEventListener("click", ()=>{
        ARbtn.click();
    });

    window.addEventListener("resize", ()=>renderer.setSize(window.innerWidth,window.innerHeight));
}


// Spawn selected object
function spawnObject() {
    if (!reticle.visible) return;

    let obj;

    if (selectedType === "cube") obj = createCube();
    else if (selectedType === "chair" && assets.chair) obj = assets.chair.clone();
    else if (selectedType === "box" && assets.box) obj = assets.box.clone();
    else if (selectedType === "lamp" && assets.lamp) obj = assets.lamp.clone();
    else return;

    obj.position.setFromMatrixPosition(reticle.matrix);
    scene.add(obj);

    addBoundingBoxAndLabel(obj);
}


function animate() {
    renderer.setAnimationLoop(render);
}

function render(ts, frame) {

    if (frame) {
        const session = renderer.xr.getSession();
        const refSpace = renderer.xr.getReferenceSpace();

        if (!hitTestRequested) {
            session.requestReferenceSpace("viewer").then(viewer => {
                session.requestHitTestSource({ space: viewer }).then(source => hitTestSource = source);
            });

            session.addEventListener("end", ()=>{
                hitTestSource = null;
                hitTestRequested = false;
            });

            hitTestRequested = true;
        }

        if (hitTestSource) {
            const hits = frame.getHitTestResults(hitTestSource);
            if (hits.length) {
                const pose = hits[0].getPose(refSpace);
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
            } else {
                reticle.visible = false;
            }
        }
    }

    renderer.render(scene,camera);
}

</script>

</body>
</html>
