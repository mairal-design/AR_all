<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>AR Multi Model + Bounding Box + Labels</title>

<!-- Import Map -->
<script type="importmap">
{
    "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/"
    }
}
</script>

<style>
body { margin: 0; overflow: hidden; font-family: Arial; }
#startAR {
    position: absolute;
    top: 10px; left: 10px;
    padding: 10px 16px;
    z-index: 20;
    background: white;
    border-radius: 8px;
    border: 1px solid #ccc;
}
</style>
</head>
<body>

<button id="startAR">Start AR</button>

<script type="module">

import * as THREE from 'three';
import { ARButton } from 'three/addons/webxr/ARButton.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

let scene, camera, renderer;
let reticle;
let hitTestSource = null;
let hitTestSourceRequested = false;
let model1, model2;
let placed = false;

// -------------------------------------------------------
// TEXT LABEL (Canvas Sprite)
// -------------------------------------------------------
function makeTextLabel(text) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = 512;
    canvas.height = 256;

    ctx.font = "60px Arial";
    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 8;

    ctx.strokeText(text, 20, 150);
    ctx.fillText(text, 20, 150);

    const tex = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
    sprite.scale.set(0.5, 0.25, 1);
    return sprite;
}

// -------------------------------------------------------
// BOUNDING BOX + LABEL
// -------------------------------------------------------
function addBoundingBoxAndLabel(obj) {
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3();
    box.getSize(size);

    const width = size.x.toFixed(2);
    const height = size.y.toFixed(2);

    // Red bounding box
    const helper = new THREE.Box3Helper(box, 0xff0000);
    scene.add(helper);

    const center = new THREE.Vector3();
    box.getCenter(center);

    const label = makeTextLabel(`W: ${width}m | H: ${height}m`);
    label.position.set(center.x, center.y + size.y * 0.7, center.z);
    scene.add(label);
}

// -------------------------------------------------------
// INIT
// -------------------------------------------------------
function init() {

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // light
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));

    // LOADER
    const loader = new GLTFLoader();

    loader.load("./wine-lady-modified.glb", (gltf) => {
        model1 = gltf.scene;
        model1.scale.set(1, 1, 1);
        model1.visible = false;
        scene.add(model1);
    });

    loader.load("./chair1.glb", (gltf) => {
        model2 = gltf.scene;
        model2.scale.set(1, 1, 1);
        model2.visible = false;
        scene.add(model2);
    });

    // RETICLE
    reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.1, 0.15, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Controller tap
    const controller = renderer.xr.getController(0);
    controller.addEventListener("select", placeObjects);
    scene.add(controller);

    window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // The AR Button itself must be visible in DOM
    const arBtn = ARButton.createButton(renderer, {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
    });
    document.body.appendChild(arBtn);

    // Start AR session programmatically on click
    document.getElementById("startAR").onclick = () => {
        arBtn.click();
    };

    renderer.setAnimationLoop(render);
}

// -------------------------------------------------------
// PLACE MODELS
// -------------------------------------------------------
function placeObjects() {
    if (!reticle.visible || placed === true || !model1 || !model2) return;

    const pos = new THREE.Vector3();
    pos.setFromMatrixPosition(reticle.matrix);

    // First model at reticle
    model1.position.copy(pos);
    model1.visible = true;
    addBoundingBoxAndLabel(model1);

    // Second model beside first
    model2.position.copy(pos);
    model2.position.x += 0.4;
    model2.visible = true;
    addBoundingBoxAndLabel(model2);

    placed = true;
}

// -------------------------------------------------------
// RENDER LOOP
// -------------------------------------------------------
function render(timestamp, frame) {

    if (frame) {
        const session = renderer.xr.getSession();

        if (!hitTestSourceRequested) {
            session.requestReferenceSpace("viewer").then((viewerSpace) => {
                session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                    hitTestSource = source;
                });
            });

            session.addEventListener("end", () => {
                hitTestSourceRequested = false;
                hitTestSource = null;
            });

            hitTestSourceRequested = true;
        }

        if (hitTestSource) {
            const refSpace = renderer.xr.getReferenceSpace();
            const hits = frame.getHitTestResults(hitTestSource);

            if (hits.length) {
                const hit = hits[0];
                const pose = hit.getPose(refSpace);
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
            } else {
                reticle.visible = false;
            }
        }
    }

    renderer.render(scene, camera);
}

// -------------------------------------------------------
init();
</script>

</body>
</html>
